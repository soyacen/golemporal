package main

import (
	"flag"
	"fmt"
	"strings"

	"github.com/soyacen/golemporal/cmd/protoc-gen-golemporal/constant"
	"google.golang.org/protobuf/compiler/protogen"
)

func main() {
	var flags flag.FlagSet
	opts := &protogen.Options{
		ParamFunc: flags.Set,
	}
	opts.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if f.Generate {
				generateFile(gen, f)
			}
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_temporal.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// Generate header
	g.P("// Code generated by protoc-gen-golemporal. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-golemporal ", gen.Request.GetCompilerVersion())
	g.P("// - protoc             ", "unknown")
	g.P("// source: ", file.Desc.Path())
	g.P()

	g.P("package ", file.GoPackageName)
	g.P()

	// Generate imports
	g.P("import (")
	g.P(`"github.com/soyacen/golemporal/starter"`)
	g.P(`"go.temporal.io/sdk/activity"`)
	g.P(`"go.temporal.io/sdk/client"`)
	g.P(`"go.temporal.io/sdk/worker"`)
	g.P(`"go.temporal.io/sdk/workflow"`)
	g.P(")")
	g.P()

	// Process services
	for _, svc := range file.Services {
		serviceName := string(svc.Desc.Name())

		if strings.HasSuffix(serviceName, "Workflow") {
			generateWorkflowClient(g, svc, serviceName)
			g.P()
			generateWorkflowServer(g, svc, serviceName)
		} else if strings.HasSuffix(serviceName, "Activity") {
			generateActivityClient(g, svc, serviceName)
			g.P()
			generateActivityServer(g, svc, serviceName)
		}
	}
}

func generateWorkflowClient(g *protogen.GeneratedFile, svc *protogen.Service, serviceName string) {
	clientName := serviceName + "Client"
	shortName := strings.TrimSuffix(serviceName, "Workflow")
	fileDesc := svc.Desc.ParentFile()
	fullMethodName := fmt.Sprintf("/%s.%s/%s", fileDesc.Package(), svc.Desc.Name(), svc.Methods[0].Desc.Name())

	// Generate constant
	g.P("const (")
	g.P("", toUpperCase(shortName), "_", toUpperCase(string(svc.Methods[0].Desc.Name())), "_FullMethodName = \"", fullMethodName, "\"")
	g.P(")")
	g.P()

	// Generate interface
	g.P("type ", clientName, " interface {")
	for _, method := range svc.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("", method.Desc.Name(), "(ctx ", constant.ContextIdent, ", in *", inputType, ", opts ...starter.Option) (*", outputType, ", error)")
	}
	g.P("}")
	g.P()

	// Generate private struct
	g.P("type ", toLowerCase(shortName), "Client struct {")
	g.P("c         client.Client")
	g.P("taskQueue string")
	g.P("}")
	g.P()

	// Generate constructor
	g.P("func New", clientName, "(c client.Client, taskQueue string) ", clientName, " {")
	g.P("return &", toLowerCase(shortName), "Client{c: c, taskQueue: taskQueue}")
	g.P("}")
	g.P()

	// Generate methods
	for _, method := range svc.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		methodName := string(method.Desc.Name())

		g.P("func (c *", toLowerCase(shortName), "Client) ", methodName, "(ctx ", constant.ContextIdent, ", in *", inputType, ", opts ...starter.Option) (*", outputType, ", error) {")
		g.P("run, err := c.c.ExecuteWorkflow(ctx, starter.NewOptions(c.taskQueue, opts...), ", toUpperCase(shortName), "_", toUpperCase(methodName), "_FullMethodName, in)")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("out := new(", outputType, ")")
		g.P("if err := run.Get(ctx, out); err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("return out, nil")
		g.P("}")
		g.P()
	}
}

func generateWorkflowServer(g *protogen.GeneratedFile, svc *protogen.Service, serviceName string) {
	shortName := strings.TrimSuffix(serviceName, "Workflow")
	// Generate interface
	g.P("type ", shortName, "Server interface {")
	for _, method := range svc.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("", method.Desc.Name(), "(", constant.WorkflowContextIdent, ", *", inputType, ") (*", outputType, ", error)")
	}
	g.P("}")
	g.P()

	// Generate register function
	g.P("func Register", shortName, "Worker(w worker.Worker, srv ", shortName, "Server) {")
	for _, method := range svc.Methods {
		g.P("w.RegisterWorkflowWithOptions(srv.", method.Desc.Name(), ", workflow.RegisterOptions{")
		g.P("Name:                          ", toUpperCase(shortName), "_", toUpperCase(string(method.Desc.Name())), "_FullMethodName,")
		g.P("DisableAlreadyRegisteredCheck: true,")
		g.P("})")
	}
	g.P("}")
}

func generateActivityClient(g *protogen.GeneratedFile, svc *protogen.Service, serviceName string) {
	shortName := strings.TrimSuffix(serviceName, "Activity")
	fileDesc := svc.Desc.ParentFile()
	fullMethodName := fmt.Sprintf("/%s.%s/%s", fileDesc.Package(), svc.Desc.Name(), svc.Methods[0].Desc.Name())

	// Generate constant
	g.P("const (")
	g.P("", toUpperCase(shortName), "_", toUpperCase(string(svc.Methods[0].Desc.Name())), "_FullMethodName = \"", fullMethodName, "\"")
	g.P(")")
	g.P()

	// Generate interface
	g.P("type ", shortName, "ActivityClient interface {")
	for _, method := range svc.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("", method.Desc.Name(), "(ctx ", constant.WorkflowContextIdent, ", in *", inputType, ") (*", outputType, ", error)")
	}
	g.P("}")
	g.P()

	// Generate constructor
	g.P("func New", shortName, "ActivityClient() ", shortName, "ActivityClient {")
	g.P("return &", toLowerCase(shortName), "ActivityClient{}")
	g.P("}")
	g.P()

	// Generate private struct
	g.P("type ", toLowerCase(shortName), "ActivityClient struct {}")
	g.P()

	// Generate methods
	for _, method := range svc.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		methodName := string(method.Desc.Name())

		g.P("func (c *", toLowerCase(shortName), "ActivityClient) ", methodName, "(ctx ", constant.WorkflowContextIdent, ", in *", inputType, ") (*", outputType, ", error) {")
		g.P("var out ", outputType)
		g.P("err := workflow.ExecuteActivity(ctx, ", toUpperCase(shortName), "_", toUpperCase(methodName), "_FullMethodName, in).Get(ctx, &out)")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("return &out, nil")
		g.P("}")
		g.P()
	}
}

func generateActivityServer(g *protogen.GeneratedFile, svc *protogen.Service, serviceName string) {
	shortName := strings.TrimSuffix(serviceName, "Activity")
	// Generate interface
	g.P("type ", shortName, "Server interface {")
	for _, method := range svc.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("", method.Desc.Name(), "(", constant.ContextIdent, ", *", inputType, ") (*", outputType, ", error)")
	}
	g.P("}")
	g.P()

	// Generate register function
	g.P("func Register", shortName, "Activity(w worker.Worker, srv ", shortName, "Server) {")
	for _, method := range svc.Methods {
		g.P("w.RegisterActivityWithOptions(srv.", method.Desc.Name(), ", activity.RegisterOptions{")
		g.P("Name:                          ", toUpperCase(shortName), "_", toUpperCase(string(method.Desc.Name())), "_FullMethodName,")
		g.P("DisableAlreadyRegisteredCheck: true,")
		g.P("})")
	}
	g.P("}")
}

func toUpperCase(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func toLowerCase(s string) string {
	if s == "" {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}
