package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

var (
	contextPackage = protogen.GoImportPath("context")
	contextIdent   = contextPackage.Ident("Context")
)

var (
	workflowPackage      = protogen.GoImportPath("go.temporal.io/sdk/workflow")
	workflowContextIdent = workflowPackage.Ident("Context")
)

var (
	workerPackage      = protogen.GoImportPath("go.temporal.io/sdk/worker")
	workerContextIdent = workerPackage.Ident("Worker")
)

var (
	activityPackage              = protogen.GoImportPath("go.temporal.io/sdk/activity")
	activityRegisterOptionsIdent = activityPackage.Ident("RegisterOptions")
)

var (
	clientPackage     = protogen.GoImportPath("go.temporal.io/sdk/client")
	clientClientIdent = clientPackage.Ident("Client")
)

var (
	starterPackage         = protogen.GoImportPath("github.com/soyacen/golemporal/starter")
	starterOptionIdent     = starterPackage.Ident("Option")
	starterNewOptionsIdent = starterPackage.Ident("NewOptions")
)

var flags flag.FlagSet

var Version = "v0.0.0"

func main() {
	if len(os.Args) == 2 && os.Args[1] == "--version" {
		_, _ = fmt.Fprintf(os.Stdout, "%v %v\n", filepath.Base(os.Args[0]), Version)
		os.Exit(0)
	}
	options := &protogen.Options{ParamFunc: flags.Set}
	options.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}
			if len(file.Services) <= 0 {
				continue
			}
			var workflowCount int
			for _, svc := range file.Services {
				serviceName := string(svc.Desc.Name())
				if strings.HasSuffix(serviceName, "Workflow") {
					workflowCount++
				}
			}
			if workflowCount <= 0 {
				continue
			}
			if workflowCount > 1 {
				return fmt.Errorf("only one workflow service is supported")
			}
			generateFile(plugin, file)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_temporal.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-golemporal. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	var activities []*protogen.Service
	for _, svc := range file.Services {
		serviceName := string(svc.Desc.Name())
		if strings.HasSuffix(serviceName, "Activity") {
			generateActivityClient(g, svc)
			generateActivityServer(g, svc)
			activities = append(activities, svc)
		}
	}

	var workflow *protogen.Service
	// only one workflow service is supported, so we can break after the first one
	for _, svc := range file.Services {
		serviceName := string(svc.Desc.Name())
		if strings.HasSuffix(serviceName, "Workflow") {
			generateWorkflowClient(g, svc)
			generateWorkflowServer(g, svc)
			workflow = svc
			break
		}
	}
	generateRegisterFunction(g, workflow, activities)
}

func generateActivityClient(g *protogen.GeneratedFile, svc *protogen.Service) {
	clientName := string(svc.Desc.Name()) + "Client"
	g.P("type ", clientName, " interface {")
	for _, method := range svc.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("", method.Desc.Name(), "(ctx ", workflowContextIdent, ", in *", inputType, ") (*", outputType, ", error)")
	}
	g.P("}")
	g.P()

	// Generate constructor
	g.P("func New", clientName, "() ", clientName, " {")
	g.P("return &", toLowerCase(clientName), "{}")
	g.P("}")
	g.P()

	// Generate private struct
	g.P("type ", toLowerCase(clientName), " struct {}")
	g.P()

	// Generate methods
	for _, method := range svc.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		methodName := string(method.Desc.Name())
		g.P("func (c *", toLowerCase(clientName), ") ", methodName, "(ctx ", workflowContextIdent, ", in *", inputType, ") (*", outputType, ", error) {")
		g.P("var out ", outputType)
		g.P("err := workflow.ExecuteActivity(ctx, ", strconv.Quote(methodFullName(method)), ", in).Get(ctx, &out)")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("return &out, nil")
		g.P("}")
		g.P()
	}
}

func generateActivityServer(g *protogen.GeneratedFile, svc *protogen.Service) {
	serverName := string(svc.Desc.Name()) + "Server"
	// Generate interface
	g.P("type ", serverName, " interface {")
	for _, method := range svc.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("", method.Desc.Name(), "(", contextIdent, ", *", inputType, ") (*", outputType, ", error)")
	}
	g.P("}")
	g.P()
}

func generateWorkflowClient(g *protogen.GeneratedFile, svc *protogen.Service) {
	clientName := string(svc.Desc.Name()) + "Client"
	// Generate interface
	g.P("type ", clientName, " interface {")
	for _, method := range svc.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("", method.Desc.Name(), "(ctx ", contextIdent, ", in *", inputType, ", opts ...", starterOptionIdent, ") (*", outputType, ", error)")
	}
	g.P("}")
	g.P()

	// Generate private struct
	g.P("type ", toLowerCase(clientName), " struct {")
	g.P("c ", clientClientIdent)
	g.P("taskQueue string")
	g.P("}")
	g.P()

	// Generate constructor
	g.P("func New", clientName, "(c ", clientClientIdent, ", taskQueue string) ", clientName, " {")
	g.P("return &", toLowerCase(clientName), "{c: c, taskQueue: taskQueue}")
	g.P("}")
	g.P()

	// Generate methods
	for _, method := range svc.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		methodName := string(method.Desc.Name())

		g.P("func (c *", toLowerCase(clientName), ") ", methodName, "(ctx ", contextIdent, ", in *", inputType, ", opts ...", starterOptionIdent, ") (*", outputType, ", error) {")
		g.P("run, err := c.c.ExecuteWorkflow(ctx, ", starterNewOptionsIdent, "(c.taskQueue, opts...), ", strconv.Quote(methodFullName(method)), ", in)")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("out := new(", outputType, ")")
		g.P("if err := run.Get(ctx, out); err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("return out, nil")
		g.P("}")
		g.P()
	}
}

func generateWorkflowServer(g *protogen.GeneratedFile, svc *protogen.Service) {
	serverName := string(svc.Desc.Name()) + "Server"
	g.P("type ", serverName, " interface {")
	for _, method := range svc.Methods {
		inputType := method.Input.GoIdent.GoName
		outputType := method.Output.GoIdent.GoName
		g.P("", method.Desc.Name(), "(", workflowContextIdent, ", *", inputType, ") (*", outputType, ", error)")
	}
	g.P("}")
	g.P()
}

func generateRegisterFunction(g *protogen.GeneratedFile, workflow *protogen.Service, activities []*protogen.Service) {
	g.P("func Register", string(workflow.Desc.Name()), "Worker(")
	g.P("w ", workerContextIdent, ",")
	g.P("wf ", string(workflow.Desc.Name()), "Server,")
	for _, activity := range activities {
		activityName := string(activity.Desc.Name())
		g.P(toLowerCase(activityName), " ", activityName, "Server,")
	}
	g.P(") {")
	for _, activity := range activities {
		activityName := string(activity.Desc.Name())
		for _, method := range activity.Methods {
			g.P("w.RegisterActivityWithOptions(", toLowerCase(activityName), ".", method.Desc.Name(), ", ", activityRegisterOptionsIdent, "{")
			g.P("Name: ", strconv.Quote(methodFullName(method)), ",")
			g.P("DisableAlreadyRegisteredCheck: true,")
			g.P("})")
			g.P()
		}
	}
	for _, method := range workflow.Methods {
		g.P("w.RegisterWorkflowWithOptions(wf.", method.Desc.Name(), ", workflow.RegisterOptions{")
		g.P("Name: ", strconv.Quote(methodFullName(method)), ",")
		g.P("DisableAlreadyRegisteredCheck: true,")
		g.P("})")
		g.P()
	}
	g.P("}")
	g.P()
}

func toLowerCase(s string) string {
	if s == "" {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func methodFullName(protoMethod *protogen.Method) string {
	return fmt.Sprintf("/%s/%s", protoMethod.Parent.Desc.FullName(), protoMethod.Desc.Name())
}
